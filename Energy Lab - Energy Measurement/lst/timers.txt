; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\timers.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\timers.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\inc -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Freescale\Kinetis -D__MICROLIB --omf_browse=.\obj\timers.crf src\timers.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;677     */
;;;678    __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;679    {
;;;680      if(IRQn < 0) {
000002  2800              CMP      r0,#0
000004  da19              BGE      |L1.58|
;;;681        SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
000006  4aca              LDR      r2,|L1.816|
000008  0703              LSLS     r3,r0,#28
00000a  0f1b              LSRS     r3,r3,#28
00000c  3b08              SUBS     r3,r3,#8
00000e  089b              LSRS     r3,r3,#2
000010  009b              LSLS     r3,r3,#2
000012  58d2              LDR      r2,[r2,r3]
000014  0783              LSLS     r3,r0,#30
000016  0edc              LSRS     r4,r3,#27
000018  23ff              MOVS     r3,#0xff
00001a  40a3              LSLS     r3,r3,r4
00001c  439a              BICS     r2,r2,r3
00001e  078b              LSLS     r3,r1,#30
000020  0e1b              LSRS     r3,r3,#24
000022  0784              LSLS     r4,r0,#30
000024  0ee4              LSRS     r4,r4,#27
000026  40a3              LSLS     r3,r3,r4
000028  431a              ORRS     r2,r2,r3
00002a  4bc1              LDR      r3,|L1.816|
00002c  0704              LSLS     r4,r0,#28
00002e  0f24              LSRS     r4,r4,#28
000030  3c08              SUBS     r4,r4,#8
000032  08a4              LSRS     r4,r4,#2
000034  00a4              LSLS     r4,r4,#2
000036  511a              STR      r2,[r3,r4]
000038  e018              B        |L1.108|
                  |L1.58|
;;;682            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;683      else {
;;;684        NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
00003a  4abe              LDR      r2,|L1.820|
00003c  2303              MOVS     r3,#3
00003e  021b              LSLS     r3,r3,#8
000040  18d2              ADDS     r2,r2,r3
000042  0883              LSRS     r3,r0,#2
000044  009b              LSLS     r3,r3,#2
000046  58d2              LDR      r2,[r2,r3]
000048  0783              LSLS     r3,r0,#30
00004a  0edc              LSRS     r4,r3,#27
00004c  23ff              MOVS     r3,#0xff
00004e  40a3              LSLS     r3,r3,r4
000050  439a              BICS     r2,r2,r3
000052  078b              LSLS     r3,r1,#30
000054  0e1b              LSRS     r3,r3,#24
000056  0784              LSLS     r4,r0,#30
000058  0ee4              LSRS     r4,r4,#27
00005a  40a3              LSLS     r3,r3,r4
00005c  431a              ORRS     r2,r2,r3
00005e  4bb5              LDR      r3,|L1.820|
000060  2403              MOVS     r4,#3
000062  0224              LSLS     r4,r4,#8
000064  191b              ADDS     r3,r3,r4
000066  0884              LSRS     r4,r0,#2
000068  00a4              LSLS     r4,r4,#2
00006a  511a              STR      r2,[r3,r4]
                  |L1.108|
;;;685            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;686    }
00006c  bd10              POP      {r4,pc}
;;;687    
                          ENDP

                  Init_LPTMR PROC
;;;6      
;;;7      void Init_LPTMR(void) {
00006e  b510              PUSH     {r4,lr}
;;;8      	SIM->SCGC5 |=  SIM_SCGC5_LPTMR_MASK;
000070  48b1              LDR      r0,|L1.824|
000072  6b80              LDR      r0,[r0,#0x38]
000074  2101              MOVS     r1,#1
000076  4308              ORRS     r0,r0,r1
000078  49af              LDR      r1,|L1.824|
00007a  6388              STR      r0,[r1,#0x38]
;;;9      
;;;10     	// Configure LPTMR
;;;11     	// select 1 kHz LPO clock with prescale factor 0, dividing clock by 2
;;;12     	// resulting in 500 Hz clock
;;;13     	LPTMR0->PSR = LPTMR_PSR_PCS(1) | LPTMR_PSR_PRESCALE(0); 
00007c  2001              MOVS     r0,#1
00007e  49af              LDR      r1,|L1.828|
000080  6048              STR      r0,[r1,#4]
;;;14     	LPTMR0->CSR = LPTMR_CSR_TIE_MASK;
000082  2040              MOVS     r0,#0x40
000084  6008              STR      r0,[r1,#0]
;;;15     	LPTMR0->CMR = 50; // Generate interrupt every 50 clock ticks or 100 ms
000086  2032              MOVS     r0,#0x32
000088  6088              STR      r0,[r1,#8]
;;;16     
;;;17     	// Configure NVIC 
;;;18     	NVIC_SetPriority(LPTimer_IRQn, 128); // 0, 64, 128 or 192
00008a  2180              MOVS     r1,#0x80
00008c  201c              MOVS     r0,#0x1c
00008e  f7fffffe          BL       NVIC_SetPriority
;;;19     	NVIC_ClearPendingIRQ(LPTimer_IRQn); 
000092  201c              MOVS     r0,#0x1c
000094  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;20     	NVIC_EnableIRQ(LPTimer_IRQn);	
000098  201c              MOVS     r0,#0x1c
00009a  f7fffffe          BL       NVIC_EnableIRQ
;;;21     
;;;22     }
00009e  bd10              POP      {r4,pc}
;;;23     
                          ENDP

                  Start_LPTMR PROC
;;;24     void Start_LPTMR(void) {
0000a0  48a6              LDR      r0,|L1.828|
;;;25     	LPTMR0->CSR |= LPTMR_CSR_TEN_MASK;
0000a2  6800              LDR      r0,[r0,#0]
0000a4  2101              MOVS     r1,#1
0000a6  4308              ORRS     r0,r0,r1
0000a8  49a4              LDR      r1,|L1.828|
0000aa  6008              STR      r0,[r1,#0]
;;;26     }
0000ac  4770              BX       lr
;;;27     
                          ENDP

                  Stop_LPTMR PROC
;;;28     void Stop_LPTMR(void) {
0000ae  48a3              LDR      r0,|L1.828|
;;;29     	LPTMR0->CSR &= ~LPTMR_CSR_TEN_MASK;
0000b0  6800              LDR      r0,[r0,#0]
0000b2  0840              LSRS     r0,r0,#1
0000b4  0040              LSLS     r0,r0,#1
0000b6  49a1              LDR      r1,|L1.828|
0000b8  6008              STR      r0,[r1,#0]
;;;30     }
0000ba  4770              BX       lr
;;;31     
                          ENDP

                  LPTimer_IRQHandler PROC
;;;32     void LPTimer_IRQHandler(void) {
0000bc  b510              PUSH     {r4,lr}
;;;33     	float v_rail;
;;;34     	static uint8_t n=LED_PERIOD;
;;;35     
;;;36     	PTE->PSOR |= MASK(DEBUG_RUNNING_POS);
0000be  48a0              LDR      r0,|L1.832|
0000c0  6840              LDR      r0,[r0,#4]
0000c2  2101              MOVS     r1,#1
0000c4  0789              LSLS     r1,r1,#30
0000c6  4308              ORRS     r0,r0,r1
0000c8  499d              LDR      r1,|L1.832|
0000ca  6048              STR      r0,[r1,#4]
;;;37     	NVIC_ClearPendingIRQ(LPTimer_IRQn);
0000cc  201c              MOVS     r0,#0x1c
0000ce  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;38     	LPTMR0->CSR |= LPTMR_CSR_TCF_MASK;
0000d2  489a              LDR      r0,|L1.828|
0000d4  6800              LDR      r0,[r0,#0]
0000d6  2180              MOVS     r1,#0x80
0000d8  4308              ORRS     r0,r0,r1
0000da  4998              LDR      r1,|L1.828|
0000dc  6008              STR      r0,[r1,#0]
;;;39     
;;;40     	if (n==0) {
0000de  4899              LDR      r0,|L1.836|
0000e0  7800              LDRB     r0,[r0,#0]  ; n
0000e2  2800              CMP      r0,#0
0000e4  d109              BNE      |L1.250|
;;;41     		v_rail = Measure_VRef();
0000e6  f7fffffe          BL       Measure_VRef
0000ea  4604              MOV      r4,r0
;;;42     		Light_LEDs(v_rail);
0000ec  4620              MOV      r0,r4
0000ee  f7fffffe          BL       Light_LEDs
;;;43     		n = LED_PERIOD;
0000f2  2005              MOVS     r0,#5
0000f4  4993              LDR      r1,|L1.836|
0000f6  7008              STRB     r0,[r1,#0]
0000f8  e004              B        |L1.260|
                  |L1.250|
;;;44     	} else {
;;;45     		Control_RGB_LEDs(0,0,0);
0000fa  2200              MOVS     r2,#0
0000fc  4611              MOV      r1,r2
0000fe  4610              MOV      r0,r2
000100  f7fffffe          BL       Control_RGB_LEDs
                  |L1.260|
;;;46     	}
;;;47     	n--;
000104  488f              LDR      r0,|L1.836|
000106  7800              LDRB     r0,[r0,#0]  ; n
000108  1e40              SUBS     r0,r0,#1
00010a  498e              LDR      r1,|L1.836|
00010c  7008              STRB     r0,[r1,#0]
;;;48     }
00010e  bd10              POP      {r4,pc}
;;;49     
                          ENDP

                  Init_PIT PROC
;;;50     void Init_PIT(unsigned period) {
000110  b510              PUSH     {r4,lr}
000112  4604              MOV      r4,r0
;;;51     	// Enable clock to PIT module
;;;52     	SIM->SCGC6 |= SIM_SCGC6_PIT_MASK;
000114  4888              LDR      r0,|L1.824|
000116  6bc0              LDR      r0,[r0,#0x3c]
000118  2101              MOVS     r1,#1
00011a  05c9              LSLS     r1,r1,#23
00011c  4308              ORRS     r0,r0,r1
00011e  4986              LDR      r1,|L1.824|
000120  63c8              STR      r0,[r1,#0x3c]
;;;53     	
;;;54     	// Enable module, freeze timers in debug mode
;;;55     	PIT->MCR &= ~PIT_MCR_MDIS_MASK;
000122  4889              LDR      r0,|L1.840|
000124  6800              LDR      r0,[r0,#0]
000126  2102              MOVS     r1,#2
000128  4388              BICS     r0,r0,r1
00012a  4987              LDR      r1,|L1.840|
00012c  6008              STR      r0,[r1,#0]
;;;56     	PIT->MCR |= PIT_MCR_FRZ_MASK;
00012e  4608              MOV      r0,r1
000130  6800              LDR      r0,[r0,#0]
000132  2101              MOVS     r1,#1
000134  4308              ORRS     r0,r0,r1
000136  4984              LDR      r1,|L1.840|
000138  6008              STR      r0,[r1,#0]
;;;57     	
;;;58     	// Initialize PIT0 to count down from argument 
;;;59     	PIT->CHANNEL[0].LDVAL = PIT_LDVAL_TSV(period);
00013a  4884              LDR      r0,|L1.844|
00013c  6004              STR      r4,[r0,#0]
;;;60     
;;;61     	// No chaining
;;;62     	PIT->CHANNEL[0].TCTRL &= PIT_TCTRL_CHN_MASK;
00013e  6880              LDR      r0,[r0,#8]
000140  2104              MOVS     r1,#4
000142  4008              ANDS     r0,r0,r1
000144  4981              LDR      r1,|L1.844|
000146  6088              STR      r0,[r1,#8]
;;;63     	
;;;64     	// Generate interrupts
;;;65     	PIT->CHANNEL[0].TCTRL |= PIT_TCTRL_TIE_MASK;
000148  4608              MOV      r0,r1
00014a  6880              LDR      r0,[r0,#8]
00014c  2102              MOVS     r1,#2
00014e  4308              ORRS     r0,r0,r1
000150  497e              LDR      r1,|L1.844|
000152  6088              STR      r0,[r1,#8]
;;;66     
;;;67     	/* Enable Interrupts */
;;;68     	NVIC_SetPriority(PIT_IRQn, 128); // 0, 64, 128 or 192
000154  2180              MOVS     r1,#0x80
000156  2016              MOVS     r0,#0x16
000158  f7fffffe          BL       NVIC_SetPriority
;;;69     	NVIC_ClearPendingIRQ(PIT_IRQn); 
00015c  2016              MOVS     r0,#0x16
00015e  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;70     	NVIC_EnableIRQ(PIT_IRQn);	
000162  2016              MOVS     r0,#0x16
000164  f7fffffe          BL       NVIC_EnableIRQ
;;;71     }
000168  bd10              POP      {r4,pc}
;;;72     
                          ENDP

                  Start_PIT PROC
;;;73     
;;;74     void Start_PIT(void) {
00016a  4878              LDR      r0,|L1.844|
;;;75     // Enable counter
;;;76     	PIT->CHANNEL[0].TCTRL |= PIT_TCTRL_TEN_MASK;
00016c  6880              LDR      r0,[r0,#8]
00016e  2101              MOVS     r1,#1
000170  4308              ORRS     r0,r0,r1
000172  4976              LDR      r1,|L1.844|
000174  6088              STR      r0,[r1,#8]
;;;77     }
000176  4770              BX       lr
;;;78     
                          ENDP

                  Stop_PIT PROC
;;;79     void Stop_PIT(void) {
000178  4874              LDR      r0,|L1.844|
;;;80     // Enable counter
;;;81     	PIT->CHANNEL[0].TCTRL &= ~PIT_TCTRL_TEN_MASK;
00017a  6880              LDR      r0,[r0,#8]
00017c  0841              LSRS     r1,r0,#1
00017e  0049              LSLS     r1,r1,#1
000180  4872              LDR      r0,|L1.844|
000182  6081              STR      r1,[r0,#8]
;;;82     }
000184  4770              BX       lr
;;;83     
                          ENDP

                  PIT_IRQHandler PROC
;;;84     
;;;85     void PIT_IRQHandler() {
000186  b510              PUSH     {r4,lr}
;;;86     	float v_rail;
;;;87     	static uint8_t n=0;
;;;88     	static uint8_t n_clk=2;
;;;89     	static uint8_t divider = 1;
;;;90     	
;;;91     	//clear pending IRQ
;;;92     	NVIC_ClearPendingIRQ(PIT_IRQn);
000188  2016              MOVS     r0,#0x16
00018a  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;93     	// check to see which channel triggered interrupt 
;;;94     	if (PIT->CHANNEL[0].TFLG & PIT_TFLG_TIF_MASK) {
00018e  486f              LDR      r0,|L1.844|
000190  68c0              LDR      r0,[r0,#0xc]
000192  07c0              LSLS     r0,r0,#31
000194  0fc0              LSRS     r0,r0,#31
000196  d03e              BEQ      |L1.534|
;;;95     		// clear status flag for timer channel 0
;;;96     		PIT->CHANNEL[0].TFLG &= PIT_TFLG_TIF_MASK;
000198  486c              LDR      r0,|L1.844|
00019a  68c0              LDR      r0,[r0,#0xc]
00019c  07c1              LSLS     r1,r0,#31
00019e  0fc9              LSRS     r1,r1,#31
0001a0  486a              LDR      r0,|L1.844|
0001a2  60c1              STR      r1,[r0,#0xc]
;;;97     		
;;;98     		// Do ISR work
;;;99     		if (n) {
0001a4  486a              LDR      r0,|L1.848|
0001a6  7800              LDRB     r0,[r0,#0]  ; n
0001a8  2800              CMP      r0,#0
0001aa  d006              BEQ      |L1.442|
;;;100    			v_rail = Measure_VRef();
0001ac  f7fffffe          BL       Measure_VRef
0001b0  4604              MOV      r4,r0
;;;101    			Light_LEDs(v_rail);
0001b2  4620              MOV      r0,r4
0001b4  f7fffffe          BL       Light_LEDs
0001b8  e004              B        |L1.452|
                  |L1.442|
;;;102    		} else {
;;;103    			Control_RGB_LEDs(0,0,0);
0001ba  2200              MOVS     r2,#0
0001bc  4611              MOV      r1,r2
0001be  4610              MOV      r0,r2
0001c0  f7fffffe          BL       Control_RGB_LEDs
                  |L1.452|
;;;104    		}
;;;105    		n = 1-n;
0001c4  4862              LDR      r0,|L1.848|
0001c6  7800              LDRB     r0,[r0,#0]  ; n
0001c8  2101              MOVS     r1,#1
0001ca  1a08              SUBS     r0,r1,r0
0001cc  4960              LDR      r1,|L1.848|
0001ce  7008              STRB     r0,[r1,#0]
;;;106    
;;;107    #if 1		
;;;108    		if (--n_clk == 0) {
0001d0  4860              LDR      r0,|L1.852|
0001d2  7800              LDRB     r0,[r0,#0]  ; n_clk
0001d4  1e40              SUBS     r0,r0,#1
0001d6  0600              LSLS     r0,r0,#24
0001d8  0e00              LSRS     r0,r0,#24
0001da  495e              LDR      r1,|L1.852|
0001dc  7008              STRB     r0,[r1,#0]
0001de  d125              BNE      |L1.556|
;;;109    			// change clock frequency
;;;110    			n_clk = 2;
0001e0  2002              MOVS     r0,#2
0001e2  7008              STRB     r0,[r1,#0]
;;;111    			SIM->CLKDIV1 = (SIM->CLKDIV1 & ~SIM_CLKDIV1_OUTDIV1_MASK) | 
0001e4  4854              LDR      r0,|L1.824|
0001e6  3040              ADDS     r0,r0,#0x40
0001e8  6840              LDR      r0,[r0,#4]
0001ea  0100              LSLS     r0,r0,#4
0001ec  0900              LSRS     r0,r0,#4
0001ee  495a              LDR      r1,|L1.856|
0001f0  7809              LDRB     r1,[r1,#0]  ; divider
0001f2  0709              LSLS     r1,r1,#28
0001f4  0f09              LSRS     r1,r1,#28
0001f6  0709              LSLS     r1,r1,#28
0001f8  4308              ORRS     r0,r0,r1
0001fa  494f              LDR      r1,|L1.824|
0001fc  3140              ADDS     r1,r1,#0x40
0001fe  6048              STR      r0,[r1,#4]
;;;112    					SIM_CLKDIV1_OUTDIV1(divider);
;;;113    			if (++divider == 16) {
000200  4855              LDR      r0,|L1.856|
000202  7800              LDRB     r0,[r0,#0]  ; divider
000204  1c40              ADDS     r0,r0,#1
000206  b2c0              UXTB     r0,r0
000208  4953              LDR      r1,|L1.856|
00020a  7008              STRB     r0,[r1,#0]
00020c  2810              CMP      r0,#0x10
00020e  d10d              BNE      |L1.556|
;;;114    				divider = 1;
000210  2001              MOVS     r0,#1
000212  7008              STRB     r0,[r1,#0]
000214  e00a              B        |L1.556|
                  |L1.534|
;;;115    			}
;;;116    		}
;;;117    #endif 
;;;118    /*
;;;119    		if (v_rail < 1.8) {
;;;120    			Control_RGB_LEDs(1, 0, 0);
;;;121    		}		
;;;122    */
;;;123    	} else if (PIT->CHANNEL[1].TFLG & PIT_TFLG_TIF_MASK) {
000216  484d              LDR      r0,|L1.844|
000218  69c0              LDR      r0,[r0,#0x1c]
00021a  07c0              LSLS     r0,r0,#31
00021c  0fc0              LSRS     r0,r0,#31
00021e  d005              BEQ      |L1.556|
;;;124    		// clear status flag for timer channel 1
;;;125    		PIT->CHANNEL[1].TFLG &= PIT_TFLG_TIF_MASK;
000220  484a              LDR      r0,|L1.844|
000222  69c0              LDR      r0,[r0,#0x1c]
000224  07c1              LSLS     r1,r0,#31
000226  0fc9              LSRS     r1,r1,#31
000228  4848              LDR      r0,|L1.844|
00022a  61c1              STR      r1,[r0,#0x1c]
                  |L1.556|
;;;126    	} 
;;;127    }
00022c  bd10              POP      {r4,pc}
;;;128    
                          ENDP

                  Init_TPM PROC
;;;129    void Init_TPM(uint32_t period_ms)
00022e  b510              PUSH     {r4,lr}
;;;130    {
000230  4604              MOV      r4,r0
;;;131    	//turn on clock to TPM 
;;;132    	SIM->SCGC6 |= SIM_SCGC6_TPM0_MASK;
000232  4841              LDR      r0,|L1.824|
000234  6bc0              LDR      r0,[r0,#0x3c]
000236  2101              MOVS     r1,#1
000238  0609              LSLS     r1,r1,#24
00023a  4308              ORRS     r0,r0,r1
00023c  493e              LDR      r1,|L1.824|
00023e  63c8              STR      r0,[r1,#0x3c]
;;;133    	
;;;134    	//set clock source for tpm to be TPM Source 3 which is MCGIR (32 kHz)
;;;135    	SIM->SOPT2 |= SIM_SOPT2_TPMSRC(3);
000240  4608              MOV      r0,r1
000242  6840              LDR      r0,[r0,#4]
000244  2103              MOVS     r1,#3
000246  0609              LSLS     r1,r1,#24
000248  4308              ORRS     r0,r0,r1
00024a  493b              LDR      r1,|L1.824|
00024c  6048              STR      r0,[r1,#4]
;;;136    
;;;137    	// disable TPM
;;;138    	TPM0->SC = 0;
00024e  2000              MOVS     r0,#0
000250  4942              LDR      r1,|L1.860|
000252  6008              STR      r0,[r1,#0]
;;;139    
;;;140    	//set TPM to count up and divide by 32 with prescaler and use clock mode
;;;141    	// will count at 1 kHz
;;;142    	TPM0->SC = (TPM_SC_PS(5));
000254  2005              MOVS     r0,#5
000256  6008              STR      r0,[r1,#0]
;;;143    	
;;;144    	//load the counter and mod. Note: 16-bit counter, not 32-bit
;;;145    	TPM0->MOD = TPM_MOD_MOD(period_ms);
000258  b2a0              UXTH     r0,r4
00025a  6088              STR      r0,[r1,#8]
;;;146    
;;;147    	
;;;148    	TPM0->SC |= TPM_SC_TOIE_MASK;
00025c  4608              MOV      r0,r1
00025e  6800              LDR      r0,[r0,#0]
000260  2140              MOVS     r1,#0x40
000262  4308              ORRS     r0,r0,r1
000264  493d              LDR      r1,|L1.860|
000266  6008              STR      r0,[r1,#0]
;;;149    
;;;150    	// Configure NVIC 
;;;151    	NVIC_SetPriority(TPM0_IRQn, 128); // 0, 64, 128 or 192
000268  2180              MOVS     r1,#0x80
00026a  2011              MOVS     r0,#0x11
00026c  f7fffffe          BL       NVIC_SetPriority
;;;152    	NVIC_ClearPendingIRQ(TPM0_IRQn); 
000270  2011              MOVS     r0,#0x11
000272  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;153    	NVIC_EnableIRQ(TPM0_IRQn);	
000276  2011              MOVS     r0,#0x11
000278  f7fffffe          BL       NVIC_EnableIRQ
;;;154    }
00027c  bd10              POP      {r4,pc}
;;;155    
                          ENDP

                  TPM0_IRQHandler PROC
;;;156    void TPM0_IRQHandler() {
00027e  b510              PUSH     {r4,lr}
;;;157    	float v_rail;
;;;158    	static uint8_t n=0;
;;;159    	static uint8_t n_clk=2;
;;;160    	static uint8_t divider = 1;
;;;161    	
;;;162    	//clear pending IRQ
;;;163    	NVIC_ClearPendingIRQ(TPM0_IRQn);
000280  2011              MOVS     r0,#0x11
000282  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;164    	
;;;165    	TPM0->SC |= TPM_SC_TOF_MASK; 
000286  4835              LDR      r0,|L1.860|
000288  6800              LDR      r0,[r0,#0]
00028a  2180              MOVS     r1,#0x80
00028c  4308              ORRS     r0,r0,r1
00028e  4933              LDR      r1,|L1.860|
000290  6008              STR      r0,[r1,#0]
;;;166    
;;;167    	// Do ISR work
;;;168    	if (n) {
000292  4833              LDR      r0,|L1.864|
000294  7800              LDRB     r0,[r0,#0]  ; n
000296  2800              CMP      r0,#0
000298  d006              BEQ      |L1.680|
;;;169    		v_rail = Measure_VRef();
00029a  f7fffffe          BL       Measure_VRef
00029e  4604              MOV      r4,r0
;;;170    		Light_LEDs(v_rail);
0002a0  4620              MOV      r0,r4
0002a2  f7fffffe          BL       Light_LEDs
0002a6  e004              B        |L1.690|
                  |L1.680|
;;;171    	} else {
;;;172    		Control_RGB_LEDs(0,0,0);
0002a8  2200              MOVS     r2,#0
0002aa  4611              MOV      r1,r2
0002ac  4610              MOV      r0,r2
0002ae  f7fffffe          BL       Control_RGB_LEDs
                  |L1.690|
;;;173    	}
;;;174    	n = 1-n;
0002b2  482b              LDR      r0,|L1.864|
0002b4  7800              LDRB     r0,[r0,#0]  ; n
0002b6  2101              MOVS     r1,#1
0002b8  1a08              SUBS     r0,r1,r0
0002ba  4929              LDR      r1,|L1.864|
0002bc  7008              STRB     r0,[r1,#0]
;;;175    #if 1		
;;;176    	if (--n_clk == 0) {
0002be  4829              LDR      r0,|L1.868|
0002c0  7800              LDRB     r0,[r0,#0]  ; n_clk
0002c2  1e40              SUBS     r0,r0,#1
0002c4  0600              LSLS     r0,r0,#24
0002c6  0e00              LSRS     r0,r0,#24
0002c8  4926              LDR      r1,|L1.868|
0002ca  7008              STRB     r0,[r1,#0]
0002cc  d119              BNE      |L1.770|
;;;177    		// change clock frequency
;;;178    		n_clk = 2;
0002ce  2002              MOVS     r0,#2
0002d0  7008              STRB     r0,[r1,#0]
;;;179    		SIM->CLKDIV1 = (SIM->CLKDIV1 & ~SIM_CLKDIV1_OUTDIV1_MASK) | 
0002d2  4819              LDR      r0,|L1.824|
0002d4  3040              ADDS     r0,r0,#0x40
0002d6  6840              LDR      r0,[r0,#4]
0002d8  0100              LSLS     r0,r0,#4
0002da  0900              LSRS     r0,r0,#4
0002dc  4922              LDR      r1,|L1.872|
0002de  7809              LDRB     r1,[r1,#0]  ; divider
0002e0  0709              LSLS     r1,r1,#28
0002e2  0f09              LSRS     r1,r1,#28
0002e4  0709              LSLS     r1,r1,#28
0002e6  4308              ORRS     r0,r0,r1
0002e8  4913              LDR      r1,|L1.824|
0002ea  3140              ADDS     r1,r1,#0x40
0002ec  6048              STR      r0,[r1,#4]
;;;180    				SIM_CLKDIV1_OUTDIV1(divider);
;;;181    		if (++divider == 16) {
0002ee  481e              LDR      r0,|L1.872|
0002f0  7800              LDRB     r0,[r0,#0]  ; divider
0002f2  1c40              ADDS     r0,r0,#1
0002f4  b2c0              UXTB     r0,r0
0002f6  491c              LDR      r1,|L1.872|
0002f8  7008              STRB     r0,[r1,#0]
0002fa  2810              CMP      r0,#0x10
0002fc  d101              BNE      |L1.770|
;;;182    			divider = 1;
0002fe  2001              MOVS     r0,#1
000300  7008              STRB     r0,[r1,#0]
                  |L1.770|
;;;183    		}
;;;184    	}
;;;185    #endif 
;;;186    }
000302  bd10              POP      {r4,pc}
;;;187    
                          ENDP

                  Start_TPM PROC
;;;188    void Start_TPM(void) {
000304  4815              LDR      r0,|L1.860|
;;;189    // Enable counter
;;;190    	TPM0->SC |= TPM_SC_CMOD(1);
000306  6800              LDR      r0,[r0,#0]
000308  2108              MOVS     r1,#8
00030a  4308              ORRS     r0,r0,r1
00030c  4913              LDR      r1,|L1.860|
00030e  6008              STR      r0,[r1,#0]
;;;191    }
000310  4770              BX       lr
;;;192    
                          ENDP

                  NVIC_EnableIRQ PROC
;;;610     */
;;;611    __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000312  06c2              LSLS     r2,r0,#27
;;;612    {
;;;613      NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000314  0ed2              LSRS     r2,r2,#27
000316  2101              MOVS     r1,#1
000318  4091              LSLS     r1,r1,r2
00031a  4a06              LDR      r2,|L1.820|
00031c  6011              STR      r1,[r2,#0]
;;;614    }
00031e  4770              BX       lr
;;;615    
                          ENDP

                  NVIC_ClearPendingIRQ PROC
;;;662     */
;;;663    __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000320  06c2              LSLS     r2,r0,#27
;;;664    {
;;;665      NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
000322  0ed2              LSRS     r2,r2,#27
000324  2101              MOVS     r1,#1
000326  4091              LSLS     r1,r1,r2
000328  4a10              LDR      r2,|L1.876|
00032a  6011              STR      r1,[r2,#0]
;;;666    }
00032c  4770              BX       lr
;;;667    
                          ENDP

00032e  0000              DCW      0x0000
                  |L1.816|
                          DCD      0xe000ed1c
                  |L1.820|
                          DCD      0xe000e100
                  |L1.824|
                          DCD      0x40048000
                  |L1.828|
                          DCD      0x40040000
                  |L1.832|
                          DCD      0x400ff100
                  |L1.836|
                          DCD      n
                  |L1.840|
                          DCD      0x40037000
                  |L1.844|
                          DCD      0x40037100
                  |L1.848|
                          DCD      |symbol_number.8|
                  |L1.852|
                          DCD      n_clk
                  |L1.856|
                          DCD      divider
                  |L1.860|
                          DCD      0x40038000
                  |L1.864|
                          DCD      |symbol_number.11|
                  |L1.868|
                          DCD      |symbol_number.12|
                  |L1.872|
                          DCD      |symbol_number.13|
                  |L1.876|
                          DCD      0xe000e280

                          AREA ||.data||, DATA, ALIGN=0

                  n
000000  05                DCB      0x05
                  |symbol_number.8|
000001  00                DCB      0x00
                  n_clk
000002  02                DCB      0x02
                  divider
000003  01                DCB      0x01
                  |symbol_number.11|
000004  00                DCB      0x00
                  |symbol_number.12|
000005  02                DCB      0x02
                  |symbol_number.13|
000006  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "src\\timers.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_timers_c_c2d6d6b6____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_timers_c_c2d6d6b6____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_timers_c_c2d6d6b6____REVSH|
#line 130
|__asm___8_timers_c_c2d6d6b6____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
