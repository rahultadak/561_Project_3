; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\mma8451.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\mma8451.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\inc -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Freescale\Kinetis -D__MICROLIB --omf_browse=.\obj\mma8451.crf src\mma8451.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  init_mma PROC
;;;16     //i2c has to already be enabled
;;;17     int init_mma()
000000  b510              PUSH     {r4,lr}
;;;18     {
;;;19     	  //check for device
;;;20     		if(i2c_read_byte(MMA_ADDR, REG_WHOAMI) == WHOAMI)	{
000002  210d              MOVS     r1,#0xd
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       i2c_read_byte
00000a  281a              CMP      r0,#0x1a
00000c  d111              BNE      |L1.50|
;;;21     			
;;;22       		Delay(100);
00000e  2064              MOVS     r0,#0x64
000010  f7fffffe          BL       Delay
;;;23     			//turn on data ready irq; defaults to int2 (PTA15)
;;;24     			i2c_write_byte(MMA_ADDR, REG_CTRL4, 0x01);
000014  2201              MOVS     r2,#1
000016  212d              MOVS     r1,#0x2d
000018  203a              MOVS     r0,#0x3a
00001a  f7fffffe          BL       i2c_write_byte
;;;25     			Delay(100);
00001e  2064              MOVS     r0,#0x64
000020  f7fffffe          BL       Delay
;;;26     			//set active 14bit mode and 100Hz (0x19)
;;;27     			i2c_write_byte(MMA_ADDR, REG_CTRL1, 0x01);
000024  2201              MOVS     r2,#1
000026  212a              MOVS     r1,#0x2a
000028  203a              MOVS     r0,#0x3a
00002a  f7fffffe          BL       i2c_write_byte
;;;28     			
;;;29     			
;;;30     			//enable the irq in the NVIC
;;;31     			//NVIC_EnableIRQ(PORTA_IRQn);
;;;32     			return 1;
00002e  2001              MOVS     r0,#1
                  |L1.48|
;;;33     		}
;;;34     		
;;;35     		//else error
;;;36     		return 0;
;;;37     	
;;;38     }
000030  bd10              POP      {r4,pc}
                  |L1.50|
000032  2000              MOVS     r0,#0                 ;36
000034  e7fc              B        |L1.48|
;;;39     
                          ENDP

                  read_full_xyz PROC
;;;40     void read_full_xyz()
000036  b51f              PUSH     {r0-r4,lr}
;;;41     {
;;;42     	int i;
;;;43     	uint8_t data[6];
;;;44     	int16_t temp[3];
;;;45     	
;;;46     	i2c_start();
000038  f7fffffe          BL       i2c_start
;;;47     	i2c_read_setup(MMA_ADDR , REG_XHI);
00003c  2101              MOVS     r1,#1
00003e  203a              MOVS     r0,#0x3a
000040  f7fffffe          BL       i2c_read_setup
;;;48     	
;;;49     	for( i=0;i<6;i++)	{
000044  2400              MOVS     r4,#0
000046  e00d              B        |L1.100|
                  |L1.72|
;;;50     		if(i==5)
000048  2c05              CMP      r4,#5
00004a  d105              BNE      |L1.88|
;;;51     			data[i] = i2c_repeated_read(1);
00004c  2001              MOVS     r0,#1
00004e  f7fffffe          BL       i2c_repeated_read
000052  a902              ADD      r1,sp,#8
000054  5508              STRB     r0,[r1,r4]
000056  e004              B        |L1.98|
                  |L1.88|
;;;52     		else
;;;53     			data[i] = i2c_repeated_read(0);
000058  2000              MOVS     r0,#0
00005a  f7fffffe          BL       i2c_repeated_read
00005e  a902              ADD      r1,sp,#8
000060  5508              STRB     r0,[r1,r4]
                  |L1.98|
000062  1c64              ADDS     r4,r4,#1              ;49
                  |L1.100|
000064  2c06              CMP      r4,#6                 ;49
000066  dbef              BLT      |L1.72|
;;;54     	}
;;;55     	
;;;56     	temp[0] = (int16_t)((data[0]<<8) | (data[1]<<2));
000068  4668              MOV      r0,sp
00006a  7a00              LDRB     r0,[r0,#8]
00006c  0201              LSLS     r1,r0,#8
00006e  4668              MOV      r0,sp
000070  7a40              LDRB     r0,[r0,#9]
000072  0080              LSLS     r0,r0,#2
000074  4301              ORRS     r1,r1,r0
000076  b209              SXTH     r1,r1
000078  4668              MOV      r0,sp
00007a  8001              STRH     r1,[r0,#0]
;;;57     	temp[1] = (int16_t)((data[2]<<8) | (data[3]<<2));
00007c  7a80              LDRB     r0,[r0,#0xa]
00007e  0201              LSLS     r1,r0,#8
000080  4668              MOV      r0,sp
000082  7ac0              LDRB     r0,[r0,#0xb]
000084  0080              LSLS     r0,r0,#2
000086  4301              ORRS     r1,r1,r0
000088  b209              SXTH     r1,r1
00008a  4668              MOV      r0,sp
00008c  8041              STRH     r1,[r0,#2]
;;;58     	temp[2] = (int16_t)((data[4]<<8) | (data[5]<<2));
00008e  7b00              LDRB     r0,[r0,#0xc]
000090  0201              LSLS     r1,r0,#8
000092  4668              MOV      r0,sp
000094  7b40              LDRB     r0,[r0,#0xd]
000096  0080              LSLS     r0,r0,#2
000098  4301              ORRS     r1,r1,r0
00009a  b209              SXTH     r1,r1
00009c  4668              MOV      r0,sp
00009e  8081              STRH     r1,[r0,#4]
;;;59     	
;;;60     	acc_X = temp[0];
0000a0  8800              LDRH     r0,[r0,#0]
0000a2  4955              LDR      r1,|L1.504|
0000a4  8008              STRH     r0,[r1,#0]
;;;61     	acc_Y = temp[1];
0000a6  4668              MOV      r0,sp
0000a8  8840              LDRH     r0,[r0,#2]
0000aa  4954              LDR      r1,|L1.508|
0000ac  8008              STRH     r0,[r1,#0]
;;;62     	acc_Z = temp[2];
0000ae  4668              MOV      r0,sp
0000b0  8880              LDRH     r0,[r0,#4]
0000b2  4953              LDR      r1,|L1.512|
0000b4  8008              STRH     r0,[r1,#0]
;;;63     }
0000b6  bd1f              POP      {r0-r4,pc}
;;;64     
                          ENDP

                  read_xyz PROC
;;;65     
;;;66     void read_xyz(void)
0000b8  b510              PUSH     {r4,lr}
;;;67     {
;;;68     	// sign extend byte to 16 bits - need to cast to signed since function
;;;69     	// returns uint8_t which is unsigned
;;;70     	acc_X = (int8_t) i2c_read_byte(MMA_ADDR, REG_XHI);
0000ba  2101              MOVS     r1,#1
0000bc  203a              MOVS     r0,#0x3a
0000be  f7fffffe          BL       i2c_read_byte
0000c2  b240              SXTB     r0,r0
0000c4  494c              LDR      r1,|L1.504|
0000c6  8008              STRH     r0,[r1,#0]
;;;71     	Delay(100);
0000c8  2064              MOVS     r0,#0x64
0000ca  f7fffffe          BL       Delay
;;;72     	acc_Y = (int8_t) i2c_read_byte(MMA_ADDR, REG_YHI);
0000ce  2103              MOVS     r1,#3
0000d0  203a              MOVS     r0,#0x3a
0000d2  f7fffffe          BL       i2c_read_byte
0000d6  b240              SXTB     r0,r0
0000d8  4948              LDR      r1,|L1.508|
0000da  8008              STRH     r0,[r1,#0]
;;;73     	Delay(100);
0000dc  2064              MOVS     r0,#0x64
0000de  f7fffffe          BL       Delay
;;;74     	acc_Z = (int8_t) i2c_read_byte(MMA_ADDR, REG_ZHI);
0000e2  2105              MOVS     r1,#5
0000e4  203a              MOVS     r0,#0x3a
0000e6  f7fffffe          BL       i2c_read_byte
0000ea  b240              SXTB     r0,r0
0000ec  4944              LDR      r1,|L1.512|
0000ee  8008              STRH     r0,[r1,#0]
;;;75     
;;;76     }
0000f0  bd10              POP      {r4,pc}
;;;77     
                          ENDP

                  convert_xyz_to_roll_pitch PROC
;;;78     void convert_xyz_to_roll_pitch(void) {
0000f2  b5f0              PUSH     {r4-r7,lr}
0000f4  b08f              SUB      sp,sp,#0x3c
;;;79     	float ax = acc_X/COUNTS_PER_G,
0000f6  4940              LDR      r1,|L1.504|
0000f8  2000              MOVS     r0,#0
0000fa  5e08              LDRSH    r0,[r1,r0]  ; acc_X
0000fc  f7fffffe          BL       __aeabi_i2d
000100  4606              MOV      r6,r0
000102  2200              MOVS     r2,#0
000104  4b3f              LDR      r3,|L1.516|
000106  f7fffffe          BL       __aeabi_ddiv
00010a  910d              STR      r1,[sp,#0x34]
00010c  900c              STR      r0,[sp,#0x30]
00010e  f7fffffe          BL       __aeabi_d2f
000112  900e              STR      r0,[sp,#0x38]
;;;80     				ay = acc_Y/COUNTS_PER_G,
000114  4939              LDR      r1,|L1.508|
000116  2000              MOVS     r0,#0
000118  5e08              LDRSH    r0,[r1,r0]  ; acc_Y
00011a  f7fffffe          BL       __aeabi_i2d
00011e  4606              MOV      r6,r0
000120  2200              MOVS     r2,#0
000122  4b38              LDR      r3,|L1.516|
000124  f7fffffe          BL       __aeabi_ddiv
000128  910d              STR      r1,[sp,#0x34]
00012a  900c              STR      r0,[sp,#0x30]
00012c  f7fffffe          BL       __aeabi_d2f
000130  4604              MOV      r4,r0
;;;81     				az = acc_Z/COUNTS_PER_G;
000132  4933              LDR      r1,|L1.512|
000134  2000              MOVS     r0,#0
000136  5e08              LDRSH    r0,[r1,r0]  ; acc_Z
000138  f7fffffe          BL       __aeabi_i2d
00013c  2200              MOVS     r2,#0
00013e  4b31              LDR      r3,|L1.516|
000140  910d              STR      r1,[sp,#0x34]
000142  900c              STR      r0,[sp,#0x30]
000144  f7fffffe          BL       __aeabi_ddiv
000148  4606              MOV      r6,r0
00014a  f7fffffe          BL       __aeabi_d2f
00014e  4605              MOV      r5,r0
;;;82     	
;;;83     	roll = atan2(ay, az)*180/M_PI;
000150  4628              MOV      r0,r5
000152  f7fffffe          BL       __aeabi_f2d
000156  4606              MOV      r6,r0
000158  460f              MOV      r7,r1
00015a  4620              MOV      r0,r4
00015c  f7fffffe          BL       __aeabi_f2d
000160  4632              MOV      r2,r6
000162  463b              MOV      r3,r7
000164  9107              STR      r1,[sp,#0x1c]
000166  9006              STR      r0,[sp,#0x18]
000168  f7fffffe          BL       atan2
00016c  2200              MOVS     r2,#0
00016e  4b26              LDR      r3,|L1.520|
000170  9109              STR      r1,[sp,#0x24]
000172  9008              STR      r0,[sp,#0x20]
000174  f7fffffe          BL       __aeabi_dmul
000178  4a24              LDR      r2,|L1.524|
00017a  4b25              LDR      r3,|L1.528|
00017c  910b              STR      r1,[sp,#0x2c]
00017e  900a              STR      r0,[sp,#0x28]
000180  f7fffffe          BL       __aeabi_ddiv
000184  910d              STR      r1,[sp,#0x34]
000186  900c              STR      r0,[sp,#0x30]
000188  f7fffffe          BL       __aeabi_d2f
00018c  4921              LDR      r1,|L1.532|
00018e  6008              STR      r0,[r1,#0]  ; roll
;;;84     	pitch = atan2(ax, sqrt(ay*ay + az*az))*180/M_PI;
000190  4629              MOV      r1,r5
000192  4628              MOV      r0,r5
000194  f7fffffe          BL       __aeabi_fmul
000198  4621              MOV      r1,r4
00019a  9002              STR      r0,[sp,#8]
00019c  4620              MOV      r0,r4
00019e  f7fffffe          BL       __aeabi_fmul
0001a2  9001              STR      r0,[sp,#4]
0001a4  9902              LDR      r1,[sp,#8]
0001a6  f7fffffe          BL       __aeabi_fadd
0001aa  9003              STR      r0,[sp,#0xc]
0001ac  f7fffffe          BL       __aeabi_f2d
0001b0  9105              STR      r1,[sp,#0x14]
0001b2  9004              STR      r0,[sp,#0x10]
0001b4  f7fffffe          BL       sqrt
0001b8  4606              MOV      r6,r0
0001ba  460f              MOV      r7,r1
0001bc  980e              LDR      r0,[sp,#0x38]
0001be  f7fffffe          BL       __aeabi_f2d
0001c2  4632              MOV      r2,r6
0001c4  463b              MOV      r3,r7
0001c6  9107              STR      r1,[sp,#0x1c]
0001c8  9006              STR      r0,[sp,#0x18]
0001ca  f7fffffe          BL       atan2
0001ce  2200              MOVS     r2,#0
0001d0  4b0d              LDR      r3,|L1.520|
0001d2  9109              STR      r1,[sp,#0x24]
0001d4  9008              STR      r0,[sp,#0x20]
0001d6  f7fffffe          BL       __aeabi_dmul
0001da  4a0c              LDR      r2,|L1.524|
0001dc  4b0c              LDR      r3,|L1.528|
0001de  910b              STR      r1,[sp,#0x2c]
0001e0  900a              STR      r0,[sp,#0x28]
0001e2  f7fffffe          BL       __aeabi_ddiv
0001e6  910d              STR      r1,[sp,#0x34]
0001e8  900c              STR      r0,[sp,#0x30]
0001ea  f7fffffe          BL       __aeabi_d2f
0001ee  490a              LDR      r1,|L1.536|
0001f0  6008              STR      r0,[r1,#0]  ; pitch
;;;85     	
;;;86     }
0001f2  b00f              ADD      sp,sp,#0x3c
0001f4  bdf0              POP      {r4-r7,pc}
;;;87     
                          ENDP

0001f6  0000              DCW      0x0000
                  |L1.504|
                          DCD      acc_X
                  |L1.508|
                          DCD      acc_Y
                  |L1.512|
                          DCD      acc_Z
                  |L1.516|
                          DCD      0x40d00000
                  |L1.520|
                          DCD      0x40668000
                  |L1.524|
                          DCD      0x53c8d4f1
                  |L1.528|
                          DCD      0x400921fb
                  |L1.532|
                          DCD      roll
                  |L1.536|
                          DCD      pitch

                          AREA ||.data||, DATA, ALIGN=2

                  acc_X
000000  0000              DCW      0x0000
                  acc_Y
000002  0000              DCW      0x0000
                  acc_Z
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  roll
000008  00000000          DCFS     0x00000000 ; 0
                  pitch
00000c  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "src\\mma8451.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_mma8451_c_acc_X____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_mma8451_c_acc_X____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_mma8451_c_acc_X____REVSH|
#line 130
|__asm___9_mma8451_c_acc_X____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
