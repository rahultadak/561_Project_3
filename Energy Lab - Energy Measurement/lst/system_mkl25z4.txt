; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\system_mkl25z4.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\system_mkl25z4.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\inc -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Freescale\Kinetis -D__MICROLIB --omf_browse=.\obj\system_mkl25z4.crf src\system_MKL25Z4.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;90     
;;;91     void SystemInit (void) {
000000  2000              MOVS     r0,#0
;;;92     #if (DISABLE_WDOG)
;;;93       /* Disable the WDOG module */
;;;94       /* SIM_COPC: COPT=0,COPCLKS=0,COPW=0 */
;;;95       SIM->COPC = (uint32_t)0x00u;
000002  4976              LDR      r1,|L1.476|
000004  6008              STR      r0,[r1,#0]
;;;96     #endif /* (DISABLE_WDOG) */
;;;97     #if (CLOCK_SETUP == 0)
;;;98       /* SIM->CLKDIV1: OUTDIV1=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=2,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;99       SIM->CLKDIV1 = (uint32_t)0x00020000UL; /* Update system prescalers */
;;;100      /* Switch to FEI Mode */
;;;101      /* MCG->C1: CLKS=0,FRDIV=0,IREFS=1,IRCLKEN=1,IREFSTEN=0 */
;;;102      MCG->C1 = (uint8_t)0x06U;
;;;103      /* MCG_C2: LOCRE0=0,??=0,RANGE0=0,HGO0=0,EREFS0=0,LP=0,IRCS=0 */
;;;104      MCG->C2 = (uint8_t)0x00U;
;;;105      /* MCG->C4: DMX32=0,DRST_DRS=1 */
;;;106      MCG->C4 = (uint8_t)((MCG->C4 & (uint8_t)~(uint8_t)0xC0U) | (uint8_t)0x20U);
;;;107      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
;;;108      OSC0->CR = (uint8_t)0x80U;
;;;109      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
;;;110      MCG->C5 = (uint8_t)0x00U;
;;;111      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;112      MCG->C6 = (uint8_t)0x00U;
;;;113      while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) { /* Check that the source of the FLL reference clock is the internal reference clock. */
;;;114      }
;;;115      while((MCG->S & 0x0CU) != 0x00U) {    /* Wait until output of the FLL is selected */
;;;116      }
;;;117    #elif (CLOCK_SETUP == 1)
;;;118      /* SIM->SCGC5: PORTA=1 */
;;;119      SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */
000006  4876              LDR      r0,|L1.480|
000008  6b80              LDR      r0,[r0,#0x38]
00000a  1549              ASRS     r1,r1,#21
00000c  4308              ORRS     r0,r0,r1
00000e  4974              LDR      r1,|L1.480|
000010  6388              STR      r0,[r1,#0x38]
;;;120      /* SIM->CLKDIV1: OUTDIV1=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;121      SIM->CLKDIV1 = (uint32_t)0x10010000UL; /* Update system prescalers */
000012  4874              LDR      r0,|L1.484|
000014  4972              LDR      r1,|L1.480|
000016  3140              ADDS     r1,r1,#0x40
000018  6048              STR      r0,[r1,#4]
;;;122      /* PORTA->PCR18: ISF=0,MUX=0 */
;;;123      PORTA->PCR[18] &= (uint32_t)~0x01000700UL;
00001a  4873              LDR      r0,|L1.488|
00001c  6880              LDR      r0,[r0,#8]
00001e  4973              LDR      r1,|L1.492|
000020  4008              ANDS     r0,r0,r1
000022  4971              LDR      r1,|L1.488|
000024  6088              STR      r0,[r1,#8]
;;;124      /* PORTA->PCR19: ISF=0,MUX=0 */
;;;125      PORTA->PCR[19] &= (uint32_t)~0x01000700UL;
000026  4608              MOV      r0,r1
000028  68c0              LDR      r0,[r0,#0xc]
00002a  4970              LDR      r1,|L1.492|
00002c  4008              ANDS     r0,r0,r1
00002e  496e              LDR      r1,|L1.488|
000030  60c8              STR      r0,[r1,#0xc]
;;;126      /* Switch to FBE Mode */
;;;127      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=1,SC4P=0,SC8P=0,SC16P=1 */
;;;128      OSC0->CR = (uint8_t)0x89U;
000032  2089              MOVS     r0,#0x89
000034  496e              LDR      r1,|L1.496|
000036  7008              STRB     r0,[r1,#0]
;;;129      /* MCG->C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=1,LP=0,IRCS=0 */
;;;130      MCG->C2 = (uint8_t)0x24U;
000038  2024              MOVS     r0,#0x24
00003a  496e              LDR      r1,|L1.500|
00003c  7048              STRB     r0,[r1,#1]
;;;131      /* MCG->C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;132      MCG->C1 = (uint8_t)0x9AU;
00003e  209a              MOVS     r0,#0x9a
000040  7008              STRB     r0,[r1,#0]
;;;133      /* MCG->C4: DMX32=0,DRST_DRS=0 */
;;;134      MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;
000042  4608              MOV      r0,r1
000044  78c0              LDRB     r0,[r0,#3]
000046  06c0              LSLS     r0,r0,#27
000048  0ec0              LSRS     r0,r0,#27
00004a  70c8              STRB     r0,[r1,#3]
;;;135      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=1 */
;;;136      MCG->C5 = (uint8_t)0x01U;
00004c  2001              MOVS     r0,#1
00004e  7108              STRB     r0,[r1,#4]
;;;137      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;138      MCG->C6 = (uint8_t)0x00U;
000050  2000              MOVS     r0,#0
000052  7148              STRB     r0,[r1,#5]
;;;139      while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
000054  bf00              NOP      
                  |L1.86|
000056  4867              LDR      r0,|L1.500|
000058  7980              LDRB     r0,[r0,#6]
00005a  2110              MOVS     r1,#0x10
00005c  4208              TST      r0,r1
00005e  d1fa              BNE      |L1.86|
;;;140      }
;;;141      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
000060  bf00              NOP      
                  |L1.98|
000062  4864              LDR      r0,|L1.500|
000064  7980              LDRB     r0,[r0,#6]
000066  210c              MOVS     r1,#0xc
000068  4008              ANDS     r0,r0,r1
00006a  2808              CMP      r0,#8
00006c  d1f9              BNE      |L1.98|
;;;142      }
;;;143      /* Switch to PBE Mode */
;;;144      /* MCG->C6: LOLIE0=0,PLLS=1,CME0=0,VDIV0=0 */
;;;145      MCG->C6 = (uint8_t)0x40U;
00006e  2040              MOVS     r0,#0x40
000070  4960              LDR      r1,|L1.500|
000072  7148              STRB     r0,[r1,#5]
;;;146      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
000074  bf00              NOP      
                  |L1.118|
000076  485f              LDR      r0,|L1.500|
000078  7980              LDRB     r0,[r0,#6]
00007a  210c              MOVS     r1,#0xc
00007c  4008              ANDS     r0,r0,r1
00007e  2808              CMP      r0,#8
000080  d1f9              BNE      |L1.118|
;;;147      }
;;;148      while((MCG->S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until locked */
000082  bf00              NOP      
                  |L1.132|
000084  485b              LDR      r0,|L1.500|
000086  7980              LDRB     r0,[r0,#6]
000088  2140              MOVS     r1,#0x40
00008a  4208              TST      r0,r1
00008c  d0fa              BEQ      |L1.132|
;;;149      }
;;;150      /* Switch to PEE Mode */
;;;151      /* MCG->C1: CLKS=0,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;152      MCG->C1 = (uint8_t)0x1AU;
00008e  201a              MOVS     r0,#0x1a
000090  4958              LDR      r1,|L1.500|
000092  7008              STRB     r0,[r1,#0]
;;;153      while((MCG->S & 0x0CU) != 0x0CU) {    /* Wait until output of the PLL is selected */
000094  bf00              NOP      
                  |L1.150|
000096  4857              LDR      r0,|L1.500|
000098  7980              LDRB     r0,[r0,#6]
00009a  210c              MOVS     r1,#0xc
00009c  4008              ANDS     r0,r0,r1
00009e  280c              CMP      r0,#0xc
0000a0  d1f9              BNE      |L1.150|
;;;154      }
;;;155    #elif (CLOCK_SETUP == 2)
;;;156      /* SIM->SCGC5: PORTA=1 */
;;;157      SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */
;;;158      /* SIM->CLKDIV1: OUTDIV1=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;159      SIM->CLKDIV1 = (uint32_t)0x00000000UL; /* Update system prescalers */
;;;160      /* PORTA->PCR18: ISF=0,MUX=0 */
;;;161      PORTA->PCR[18] &= (uint32_t)~0x01000700UL;
;;;162      /* PORTA->PCR19: ISF=0,MUX=0 */
;;;163      PORTA->PCR[19] &= (uint32_t)~0x01000700UL;
;;;164      /* Switch to FBE Mode */
;;;165      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=1,SC4P=0,SC8P=0,SC16P=1 */
;;;166      OSC0->CR = (uint8_t)0x89U;
;;;167      /* MCG->C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=1,LP=0,IRCS=0 */
;;;168      MCG->C2 = (uint8_t)0x24U;
;;;169      /* MCG->C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;170      MCG->C1 = (uint8_t)0x9AU;
;;;171      /* MCG->C4: DMX32=0,DRST_DRS=0 */
;;;172      MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;
;;;173      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
;;;174      MCG->C5 = (uint8_t)0x00U;
;;;175      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;176      MCG->C6 = (uint8_t)0x00U;
;;;177      while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
;;;178      }
;;;179      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;180      }
;;;181      /* Switch to BLPE Mode */
;;;182      /* MCG->C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=1,LP=1,IRCS=0 */
;;;183      MCG->C2 = (uint8_t)0x26U;
;;;184      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;185      }
;;;186    #endif /* (CLOCK_SETUP == 2) */
;;;187    }
0000a2  4770              BX       lr
;;;188    
                          ENDP

                  SystemCoreClockUpdate PROC
;;;192    
;;;193    void SystemCoreClockUpdate (void) {
0000a4  b570              PUSH     {r4-r6,lr}
;;;194      uint32_t MCGOUTClock;                                                        /* Variable to store output clock frequency of the MCG module */
;;;195      uint8_t Divider;
;;;196    
;;;197      if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x0u) {
0000a6  4853              LDR      r0,|L1.500|
0000a8  7800              LDRB     r0,[r0,#0]
0000aa  21c0              MOVS     r1,#0xc0
0000ac  4208              TST      r0,r1
0000ae  d164              BNE      |L1.378|
;;;198        /* Output of FLL or PLL is selected */
;;;199        if ((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u) {
0000b0  4850              LDR      r0,|L1.500|
0000b2  7940              LDRB     r0,[r0,#5]
0000b4  2140              MOVS     r1,#0x40
0000b6  4208              TST      r0,r1
0000b8  d14b              BNE      |L1.338|
;;;200          /* FLL is selected */
;;;201          if ((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u) {
0000ba  484e              LDR      r0,|L1.500|
0000bc  7800              LDRB     r0,[r0,#0]
0000be  2104              MOVS     r1,#4
0000c0  4208              TST      r0,r1
0000c2  d114              BNE      |L1.238|
;;;202            /* External reference clock is selected */
;;;203            MCGOUTClock = CPU_XTAL_CLK_HZ;                                       /* System oscillator drives MCG clock */
0000c4  4c4c              LDR      r4,|L1.504|
;;;204            Divider = (uint8_t)(1u << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
0000c6  484b              LDR      r0,|L1.500|
0000c8  7800              LDRB     r0,[r0,#0]
0000ca  2138              MOVS     r1,#0x38
0000cc  4008              ANDS     r0,r0,r1
0000ce  08c1              LSRS     r1,r0,#3
0000d0  2001              MOVS     r0,#1
0000d2  4088              LSLS     r0,r0,r1
0000d4  b2c5              UXTB     r5,r0
;;;205            MCGOUTClock = (MCGOUTClock / Divider);  /* Calculate the divided FLL reference clock */
0000d6  4629              MOV      r1,r5
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       __aeabi_uidivmod
0000de  4604              MOV      r4,r0
;;;206            if ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x0u) {
0000e0  4844              LDR      r0,|L1.500|
0000e2  7840              LDRB     r0,[r0,#1]
0000e4  2130              MOVS     r1,#0x30
0000e6  4208              TST      r0,r1
0000e8  d003              BEQ      |L1.242|
;;;207              MCGOUTClock /= 32u;                                                  /* If high range is enabled, additional 32 divider is active */
0000ea  0964              LSRS     r4,r4,#5
0000ec  e001              B        |L1.242|
                  |L1.238|
;;;208            } /* ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x0u) */
;;;209          } else { /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u)) */
;;;210            MCGOUTClock = CPU_INT_SLOW_CLK_HZ;                                     /* The slow internal reference clock is selected */
0000ee  2401              MOVS     r4,#1
0000f0  03e4              LSLS     r4,r4,#15
                  |L1.242|
;;;211          } /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u)) */
;;;212          /* Select correct multiplier to calculate the MCG output clock  */
;;;213          switch (MCG->C4 & (MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) {
0000f2  4840              LDR      r0,|L1.500|
0000f4  78c0              LDRB     r0,[r0,#3]
0000f6  21e0              MOVS     r1,#0xe0
0000f8  4008              ANDS     r0,r0,r1
0000fa  06c1              LSLS     r1,r0,#27
0000fc  0ec9              LSRS     r1,r1,#27
0000fe  d126              BNE      |L1.334|
000100  1140              ASRS     r0,r0,#5
000102  0003              MOVS     r3,r0
000104  f7fffffe          BL       __ARM_common_switch8
000108  0805090d          DCB      0x08,0x05,0x09,0x0d
00010c  1115191d          DCB      0x11,0x15,0x19,0x1d
000110  2023              DCB      0x20,0x23
;;;214            case 0x0u:
;;;215              MCGOUTClock *= 640u;
000112  2005              MOVS     r0,#5
000114  01c0              LSLS     r0,r0,#7
000116  4344              MULS     r4,r0,r4
;;;216              break;
000118  e01a              B        |L1.336|
;;;217            case 0x20u:
;;;218              MCGOUTClock *= 1280u;
00011a  2005              MOVS     r0,#5
00011c  0200              LSLS     r0,r0,#8
00011e  4344              MULS     r4,r0,r4
;;;219              break;
000120  e016              B        |L1.336|
;;;220            case 0x40u:
;;;221              MCGOUTClock *= 1920u;
000122  200f              MOVS     r0,#0xf
000124  01c0              LSLS     r0,r0,#7
000126  4344              MULS     r4,r0,r4
;;;222              break;
000128  e012              B        |L1.336|
;;;223            case 0x60u:
;;;224              MCGOUTClock *= 2560u;
00012a  2005              MOVS     r0,#5
00012c  0240              LSLS     r0,r0,#9
00012e  4344              MULS     r4,r0,r4
;;;225              break;
000130  e00e              B        |L1.336|
;;;226            case 0x80u:
;;;227              MCGOUTClock *= 732u;
000132  20b7              MOVS     r0,#0xb7
000134  0080              LSLS     r0,r0,#2
000136  4344              MULS     r4,r0,r4
;;;228              break;
000138  e00a              B        |L1.336|
;;;229            case 0xA0u:
;;;230              MCGOUTClock *= 1464u;
00013a  20b7              MOVS     r0,#0xb7
00013c  00c0              LSLS     r0,r0,#3
00013e  4344              MULS     r4,r0,r4
;;;231              break;
000140  e006              B        |L1.336|
;;;232            case 0xC0u:
;;;233              MCGOUTClock *= 2197u;
000142  482e              LDR      r0,|L1.508|
000144  4344              MULS     r4,r0,r4
;;;234              break;
000146  e003              B        |L1.336|
;;;235            case 0xE0u:
;;;236              MCGOUTClock *= 2929u;
000148  482d              LDR      r0,|L1.512|
00014a  4344              MULS     r4,r0,r4
;;;237              break;
00014c  e000              B        |L1.336|
                  |L1.334|
;;;238            default:
;;;239              break;
00014e  bf00              NOP      
                  |L1.336|
000150  e037              B        |L1.450|
                  |L1.338|
;;;240          }
;;;241        } else { /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u)) */
;;;242          /* PLL is selected */
;;;243          Divider = (1u + (MCG->C5 & MCG_C5_PRDIV0_MASK));
000152  4828              LDR      r0,|L1.500|
000154  7900              LDRB     r0,[r0,#4]
000156  06c0              LSLS     r0,r0,#27
000158  0ec0              LSRS     r0,r0,#27
00015a  1c45              ADDS     r5,r0,#1
;;;244          MCGOUTClock = (uint32_t)(CPU_XTAL_CLK_HZ / Divider);                     /* Calculate the PLL reference clock */
00015c  4629              MOV      r1,r5
00015e  4826              LDR      r0,|L1.504|
000160  f7fffffe          BL       __aeabi_uidivmod
000164  4604              MOV      r4,r0
;;;245          Divider = ((MCG->C6 & MCG_C6_VDIV0_MASK) + 24u);
000166  4823              LDR      r0,|L1.500|
000168  7940              LDRB     r0,[r0,#5]
00016a  06c0              LSLS     r0,r0,#27
00016c  0ec0              LSRS     r0,r0,#27
00016e  4605              MOV      r5,r0
000170  3518              ADDS     r5,r5,#0x18
;;;246          MCGOUTClock *= Divider;                       /* Calculate the MCG output clock */
000172  4620              MOV      r0,r4
000174  4368              MULS     r0,r5,r0
000176  4604              MOV      r4,r0
000178  e023              B        |L1.450|
                  |L1.378|
;;;247        } /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u)) */
;;;248      } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x40u) {
00017a  481e              LDR      r0,|L1.500|
00017c  7800              LDRB     r0,[r0,#0]
00017e  21c0              MOVS     r1,#0xc0
000180  4008              ANDS     r0,r0,r1
000182  2840              CMP      r0,#0x40
000184  d114              BNE      |L1.432|
;;;249        /* Internal reference clock is selected */
;;;250        if ((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u) {
000186  481b              LDR      r0,|L1.500|
000188  7840              LDRB     r0,[r0,#1]
00018a  07c0              LSLS     r0,r0,#31
00018c  0fc0              LSRS     r0,r0,#31
00018e  d102              BNE      |L1.406|
;;;251          MCGOUTClock = CPU_INT_SLOW_CLK_HZ;                                       /* Slow internal reference clock selected */
000190  2401              MOVS     r4,#1
000192  03e4              LSLS     r4,r4,#15
000194  e015              B        |L1.450|
                  |L1.406|
;;;252        } else { /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u)) */
;;;253          MCGOUTClock = CPU_INT_FAST_CLK_HZ / (1 << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));  /* Fast internal reference clock selected */
000196  4817              LDR      r0,|L1.500|
000198  7a00              LDRB     r0,[r0,#8]
00019a  220e              MOVS     r2,#0xe
00019c  4010              ANDS     r0,r0,r2
00019e  0842              LSRS     r2,r0,#1
0001a0  2001              MOVS     r0,#1
0001a2  4090              LSLS     r0,r0,r2
0001a4  4601              MOV      r1,r0
0001a6  4817              LDR      r0,|L1.516|
0001a8  f7fffffe          BL       __aeabi_uidivmod
0001ac  4604              MOV      r4,r0
0001ae  e008              B        |L1.450|
                  |L1.432|
;;;254        } /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u)) */
;;;255      } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u) {
0001b0  4810              LDR      r0,|L1.500|
0001b2  7800              LDRB     r0,[r0,#0]
0001b4  21c0              MOVS     r1,#0xc0
0001b6  4008              ANDS     r0,r0,r1
0001b8  2880              CMP      r0,#0x80
0001ba  d101              BNE      |L1.448|
;;;256        /* External reference clock is selected */
;;;257        MCGOUTClock = CPU_XTAL_CLK_HZ;                                           /* System oscillator drives MCG clock */
0001bc  4c0e              LDR      r4,|L1.504|
0001be  e000              B        |L1.450|
                  |L1.448|
;;;258      } else { /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u)) */
;;;259        /* Reserved value */
;;;260        return;
;;;261      } /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u)) */
;;;262      SystemCoreClock = (MCGOUTClock / (1u + ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)));
;;;263    }
0001c0  bd70              POP      {r4-r6,pc}
                  |L1.450|
0001c2  4807              LDR      r0,|L1.480|
0001c4  3040              ADDS     r0,r0,#0x40           ;262
0001c6  6840              LDR      r0,[r0,#4]            ;262
0001c8  0f00              LSRS     r0,r0,#28             ;262
0001ca  1c41              ADDS     r1,r0,#1              ;262
0001cc  4620              MOV      r0,r4                 ;262
0001ce  f7fffffe          BL       __aeabi_uidivmod
0001d2  490d              LDR      r1,|L1.520|
0001d4  6008              STR      r0,[r1,#0]            ;262  ; SystemCoreClock
0001d6  bf00              NOP      
0001d8  e7f2              B        |L1.448|
                          ENDP

0001da  0000              DCW      0x0000
                  |L1.476|
                          DCD      0x40048100
                  |L1.480|
                          DCD      0x40048000
                  |L1.484|
                          DCD      0x10010000
                  |L1.488|
                          DCD      0x40049040
                  |L1.492|
                          DCD      0xfefff8ff
                  |L1.496|
                          DCD      0x40065000
                  |L1.500|
                          DCD      0x40064000
                  |L1.504|
                          DCD      0x007a1200
                  |L1.508|
                          DCD      0x00000895
                  |L1.512|
                          DCD      0x00000b71
                  |L1.516|
                          DCD      0x003d0900
                  |L1.520|
                          DCD      SystemCoreClock

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x02dc6c00

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L16.24|
                  |L16.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L16.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L16.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\system_MKL25Z4.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_system_MKL25Z4_c_5d646a67____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_system_MKL25Z4_c_5d646a67____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_system_MKL25Z4_c_5d646a67____REVSH|
#line 130
|__asm___16_system_MKL25Z4_c_5d646a67____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
